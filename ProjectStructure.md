# Project Structure

This document explains the folder structure and key files in the Network Monitor project.

## Directory Layout

```txt
NetworkMonitor2/
├── pom.xml                          # Maven project configuration
├── README.md                        # Project documentation
├── ProjectStructure.md              # This file
├── runApp.ps1                       # PowerShell script to run the app
├── debugApp.ps1                     # PowerShell script for debugging
├── database/                        # Database scripts
│   ├── schema.sql                   # DDL for creating tables and seed data
│   └── NetworkMonitor.sql           # Development queries (DO NOT RUN)
├── docs/                            # Additional documentation
│   ├── QuickStart.md                # Quick start guide
│   ├── VSCodeExtensions.md          # Recommended VS Code extensions
│   ├── api-tests.http               # HTTP client test requests
│   └── mqtt-examples/               # MQTT message examples
│       ├── README.md
│       └── example-message.json
├── src/
│   ├── main/
│   │   ├── java/                    # Java source code
│   │   │   └── com/matjazt/networkmonitor/
│   │   │       ├── api/             # REST API layer
│   │   │       ├── config/          # Configuration management
│   │   │       ├── dao/             # Data access layer
│   │   │       ├── entity/          # JPA database entities
│   │   │       ├── model/           # Data transfer objects (DTOs)
│   │   │       ├── security/        # Authentication & authorization
│   │   │       └── service/         # Business logic layer
│   │   ├── resources/               # Non-code resources
│   │   │   └── META-INF/
│   │   │       ├── persistence.xml              # JPA configuration
│   │   │       ├── microprofile-config.properties  # App settings
│   │   │       └── services/
│   │   │           └── org.eclipse.microprofile.config.spi.ConfigSource
│   │   └── webapp/                  # Web application resources
│   │       ├── openapi-ui.html      # OpenAPI documentation UI
│   │       └── WEB-INF/
│   │           ├── beans.xml        # CDI configuration
│   │           └── web.xml          # Web app descriptor
│   └── test/
│       └── java/                    # Unit/integration tests (future)
└── target/                          # Build output (generated by Maven)
    └── network-monitor.war          # Deployable WAR file
```

## Root Files

### pom.xml

Maven's Project Object Model file. Defines:

- Project coordinates (groupId, artifactId, version)
- Dependencies (libraries the project uses)
- Build plugins (how to compile and package)
- Java version and encoding settings

Think of this as a combination of .csproj and packages.config in .NET.

### README.md

User-facing documentation covering setup, configuration, and usage.

### ProjectStructure.md

This file - technical documentation of the codebase organization.

## Database Directory

### database/schema.sql

Complete SQL DDL script to create all database tables, indexes, foreign keys, and seed reference data. Run this once to set up the database.

Includes:

- Table definitions for all entities
- Foreign key constraints
- Indexes for query optimization
- INSERT statements for reference data (account_type, alert_type, device_operation_mode)

### database/NetworkMonitor.sql

Development and maintenance queries. **DO NOT execute this file** - it contains DROP statements and test queries. Used during development for database operations.

## Source Code Organization

Java follows package-based organization. Package names use reverse domain notation (com.matjazt.networkmonitor) to ensure global uniqueness.

### src/main/java/com/matjazt/networkmonitor/

#### api/

**REST API layer** - exposes HTTP endpoints for external consumption.

- **RestApplication.java**: Activates JAX-RS and sets API base path (`/api`). Similar to Program.cs with MapControllers() in .NET.
- **NetworkResource.java**: REST controller for network/device endpoints. Handles authentication and returns JSON responses.

Key annotations:

- `@Path`: URL routing
- `@GET/@POST/@PUT/@DELETE`: HTTP method mapping
- `@PathParam`: extracts URL path variables
- `@Produces/@Consumes`: specifies content types (JSON)
- `@Operation`, `@APIResponse`: OpenAPI documentation

#### config/

**Configuration management** - reads and provides application settings.

- **ConfigProvider.java**: Centralized configuration using MicroProfile Config. Reads from properties file, environment variables, and system properties.
- **ExternalConfigSource.java**: Custom config source implementation for MicroProfile Config.

#### dao/

**Data Access Object layer** - encapsulates database operations.

- **MonitoringDAO.java**: Queries for networks, devices, and status history
- **AlertingDAO.java**: Alert creation, retrieval, and closure operations
- **AccountManagementDAO.java**: User account and network access management

Uses EntityManager (JPA) with `@Transactional` for database transactions.

#### entity/

**JPA entities** - Java classes that map to database tables.

- **NetworkEntity.java**: Monitored networks
- **DeviceEntity.java**: Devices and their current state
- **DeviceStatusHistoryEntity.java**: Historical state changes
- **AlertEntity.java**: Generated alerts
- **AccountEntity.java**: User accounts
- **AccountNetworkEntity.java**: User-network access mapping
- **AccountTypeEntity.java**, **AlertTypeEntity.java**, **DeviceOperationModeEntity.java**: Reference tables
- **AlertType.java**, **DeviceOperationMode.java**: Enums for type-safe references

Key annotations:

- `@Entity`: marks class as JPA entity
- `@Table`: specifies table name and indexes
- `@Id`: primary key
- `@GeneratedValue`: auto-increment strategy
- `@Column`: column mapping and constraints
- `@ManyToOne/@OneToMany`: relationships
- `@Enumerated`: enum mapping

#### model/

**Data Transfer Objects (DTOs)** - simple data containers for transferring data between layers.

- **NetworkStatusMessage.java**: Matches MQTT JSON message structure
  - Contains nested `DeviceInfo` class for device data

DTOs decouple external data format from internal domain model.

#### security/

**Authentication and authorization** - Jakarta Security implementation.

- **DatabaseIdentityStore.java**: Validates user credentials against database, BCrypt password verification
- **AccountPrincipal.java**: Security principal containing authenticated user information

Implements Jakarta Security standards for authentication.

#### service/

**Business logic layer** - core application functionality.

- **MqttService.java**: Manages MQTT connection, subscription, and message handling
  - `@Singleton`: one instance per application
  - `@Startup`: created at application startup
  - `@PostConstruct`: initialization after dependency injection
  - `@PreDestroy`: cleanup before shutdown
  
- **MessageProcessingService.java**: Processes MQTT messages, detects device state changes, stores history
  
- **AlerterService.java**: Scheduled alert checking service
  - Periodic timer checks for network/device down conditions
  - Sends email notifications via Jakarta Mail
  - Manages alert lifecycle (creation and closure)

## Resources Directory

### src/main/resources/META-INF/

#### persistence.xml

JPA configuration file. Defines:

- Persistence unit name (referenced in code)
- Data source JNDI name
- Entity classes to manage
- JPA provider settings (logging, schema generation)

Must be in META-INF for JPA to discover it.

#### microprofile-config.properties

Application configuration properties. Contains:

- MQTT broker settings (URL, credentials, topic template)
- SMTP/email settings for alert notifications
- Alert timing configuration
- Logging configuration

Values can be overridden by environment variables or system properties.

## Web Application Directory

### src/main/webapp/WEB-INF/

Files in WEB-INF are not directly accessible via HTTP (protected).

#### beans.xml

CDI (Contexts and Dependency Injection) configuration. Enables dependency injection for the application.

Empty file with `bean-discovery-mode="all"` is sufficient - tells CDI to scan all classes.

#### web.xml

Web application descriptor. Configures:

- Security constraints for authentication
- Login configuration (BASIC auth)
- Security roles
- Welcome files and error pages

## Build Output

### target/

Created by Maven during build (`mvn package`). Contains:

- Compiled .class files
- Processed resources
- **network-monitor.war**: The final deployable artifact

WAR (Web Application Archive) is a ZIP file containing:

- Compiled classes
- Libraries (JARs)
- Configuration files
- Web resources

Deploy this to TomEE's webapps/ directory.

## Key Concepts

### Package Structure

Java uses packages (similar to C# namespaces) for organizing code. Package names match directory structure:

- `com.matjazt.networkmonitor.api` → `com/matjazt/networkmonitor/api/`

### Separation of Concerns

Code is organized in layers:

1. **API layer**: HTTP endpoints (NetworkResource)
2. **Service layer**: Business logic (MqttService, MessageProcessingService, AlerterService)
3. **DAO layer**: Data access (MonitoringDAO, AlertingDAO, AccountManagementDAO)
4. **Entity layer**: Database mapping (NetworkEntity, DeviceEntity, AlertEntity, etc.)
5. **Model layer**: Data transfer (NetworkStatusMessage)
6. **Security layer**: Authentication (DatabaseIdentityStore, AccountPrincipal)

Each layer has a specific responsibility. Similar to MVC or clean architecture patterns.

### Dependency Injection

Jakarta EE uses CDI for dependency injection. `@Inject` annotation injects dependencies automatically.

Example:

```java
@Inject
private NetworkRepository repository;
```

Container creates and manages instances. Similar to constructor injection in .NET.

### Annotations

Java uses annotations (like C# attributes) extensively for configuration:

- `@Entity`, `@Table`: JPA mapping
- `@Path`, `@GET`: REST endpoints
- `@Inject`: dependency injection
- `@ApplicationScoped`, `@Singleton`: bean scopes
- `@PostConstruct`, `@PreDestroy`: lifecycle callbacks

Annotations provide metadata that frameworks use at runtime.

## Maven Lifecycle

Understanding Maven build phases:

- `mvn clean`: deletes target/ directory
- `mvn compile`: compiles Java sources to .class files
- `mvn test`: runs unit tests
- `mvn package`: creates WAR file
- `mvn install`: installs WAR to local Maven repository
- `mvn clean package`: full rebuild

Most common: `mvn clean package` to build deployable WAR.

## Adding New Features

### Adding a new REST endpoint

1. Add method to `NetworkResource.java` or create new resource class
2. Annotate with `@GET/@POST/etc.` and `@Path`
3. Rebuild with `mvn package`

### Adding a database table

1. Create entity class in `entity/` package
2. Annotate with `@Entity` and field mappings
3. Add to `persistence.xml` class list
4. Create DAO methods in appropriate DAO class in `dao/` package
5. Update `database/schema.sql` with new table DDL

### Adding configuration

1. Add property to `microprofile-config.properties`
2. Inject in `ConfigProvider.java` with `@ConfigProperty`
3. Add getter method

## Comparison with .NET

| Jakarta EE | .NET Equivalent |
| ------------ | ----------------- |
| Maven | MSBuild + NuGet |
| pom.xml | .csproj |
| WAR file | Published application |
| JPA/Entities | Entity Framework/DbContext |
| CDI | Built-in DI Container |
| JAX-RS | ASP.NET Web API |
| @Path | [Route] |
| @Inject | Constructor injection |
| persistence.xml | DbContext configuration |
| JPQL | LINQ to Entities |
| EntityManager | DbContext |

Main differences:

- Java uses annotations more heavily than attributes
- Configuration often in XML (older standard) or properties files
- Explicit getter/setter methods instead of auto-properties
- Package structure mirrors directory structure (strict convention)
