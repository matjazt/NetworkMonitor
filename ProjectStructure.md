# Project Structure

This document explains the folder structure and key files in the Network Monitor project.

## Directory Layout

```
NetworkMonitor2/
├── pom.xml                          # Maven project configuration
├── README.md                        # Project documentation
├── ProjectStructure.md              # This file
├── database/                        # Database scripts
│   └── schema.sql                   # DDL for creating tables
├── src/
│   ├── main/
│   │   ├── java/                    # Java source code
│   │   │   └── com/matjazt/networkmonitor/
│   │   │       ├── api/             # REST API layer
│   │   │       ├── config/          # Configuration management
│   │   │       ├── entity/          # JPA database entities
│   │   │       ├── model/           # Data transfer objects (DTOs)
│   │   │       ├── repository/      # Data access layer
│   │   │       └── service/         # Business logic layer
│   │   ├── resources/               # Non-code resources
│   │   │   └── META-INF/
│   │   │       ├── persistence.xml  # JPA configuration
│   │   │       └── microprofile-config.properties  # App settings
│   │   └── webapp/                  # Web application resources
│   │       └── WEB-INF/
│   │           ├── beans.xml        # CDI configuration
│   │           └── resources.xml    # TomEE resource definitions
│   └── test/
│       └── java/                    # Unit/integration tests (future)
└── target/                          # Build output (generated by Maven)
    └── network-monitor.war          # Deployable WAR file
```

## Root Files

### pom.xml
Maven's Project Object Model file. Defines:
- Project coordinates (groupId, artifactId, version)
- Dependencies (libraries the project uses)
- Build plugins (how to compile and package)
- Java version and encoding settings

Think of this as a combination of .csproj and packages.config in .NET.

### README.md
User-facing documentation covering setup, configuration, and usage.

### ProjectStructure.md
This file - technical documentation of the codebase organization.

## Database Directory

### database/schema.sql
SQL DDL (Data Definition Language) script to create database tables and indexes.
Run this manually to set up the PostgreSQL database schema.

Similar to Entity Framework migrations, but simpler and explicit.

## Source Code Organization

Java follows package-based organization. Package names use reverse domain notation (com.matjazt.networkmonitor) to ensure global uniqueness.

### src/main/java/com/matjazt/networkmonitor/

#### api/
**REST API layer** - exposes HTTP endpoints for external consumption.

- **RestApplication.java**: Activates JAX-RS and sets API base path. Similar to Program.cs with MapControllers() in .NET.
- **NetworkResource.java**: REST controller for network/device endpoints. Like an ASP.NET Controller or minimal API endpoints.

Key annotations:
- `@Path`: URL routing
- `@GET/@POST/@PUT/@DELETE`: HTTP method mapping
- `@PathParam`: extracts URL path variables
- `@Produces/@Consumes`: specifies content types (JSON)

#### config/
**Configuration management** - reads and provides application settings.

- **ConfigProvider.java**: Centralized configuration using MicroProfile Config. Reads from properties file, environment variables, and system properties.

MicroProfile Config is a Jakarta EE standard, portable across servers. Similar to IConfiguration in .NET.

#### entity/
**JPA entities** - Java classes that map to database tables.

- **Network.java**: Represents a monitored network
- **DeviceStatusHistory.java**: Represents device state change events

Key annotations:
- `@Entity`: marks class as JPA entity
- `@Table`: specifies table name and indexes
- `@Id`: primary key
- `@GeneratedValue`: auto-increment strategy
- `@Column`: column mapping and constraints
- `@ManyToOne/@OneToMany`: relationships

Entities are POJOs (Plain Old Java Objects) with getters/setters - standard Java bean pattern.

#### model/
**Data Transfer Objects (DTOs)** - simple data containers for transferring data between layers.

- **NetworkStatusMessage.java**: Matches MQTT JSON message structure
  - Contains nested `DeviceInfo` class for device data

DTOs decouple external data format from internal domain model.

#### repository/
**Data access layer** - encapsulates database operations.

- **NetworkRepository.java**: Database operations for Network entities
- **DeviceStatusRepository.java**: Database operations for DeviceStatusHistory

Repositories use EntityManager (JPA's database interface) to:
- Query data with JPQL (JPA Query Language - like LINQ or SQL)
- Insert/update/delete records
- Manage transactions

`@Transactional` annotation ensures operations run in database transactions.

#### service/
**Business logic layer** - core application functionality.

- **MqttService.java**: Manages MQTT connection and subscriptions
  - `@Singleton`: one instance per application
  - `@Startup`: created at application startup
  - `@PostConstruct`: initialization after dependency injection
  - `@PreDestroy`: cleanup before shutdown
  
- **MessageProcessingService.java**: Processes MQTT messages and detects device state changes
  - Parses JSON to Java objects
  - Compares current state with database
  - Stores only actual state changes

## Resources Directory

### src/main/resources/META-INF/

#### persistence.xml
JPA configuration file. Defines:
- Persistence unit name (referenced in code)
- Data source JNDI name
- Entity classes to manage
- JPA provider settings (logging, schema generation)

Must be in META-INF for JPA to discover it.

#### microprofile-config.properties
Application configuration properties. Contains:
- MQTT broker settings
- Database credentials
- Application settings (log level, etc.)

Values can be overridden by environment variables or system properties.

## Web Application Directory

### src/main/webapp/WEB-INF/

Files in WEB-INF are not directly accessible via HTTP (protected).

#### beans.xml
CDI (Contexts and Dependency Injection) configuration. Enables dependency injection for the application.

Empty file with `bean-discovery-mode="all"` is sufficient - tells CDI to scan all classes.

#### resources.xml
TomEE-specific resource definitions. Defines:
- DataSource (database connection pool)
- JDBC driver and URL
- Connection pool settings
- Connection validation queries

In production, this would typically be in TomEE's server configuration instead.

## Build Output

### target/
Created by Maven during build (`mvn package`). Contains:
- Compiled .class files
- Processed resources
- **network-monitor.war**: The final deployable artifact

WAR (Web Application Archive) is a ZIP file containing:
- Compiled classes
- Libraries (JARs)
- Configuration files
- Web resources

Deploy this to TomEE's webapps/ directory.

## Key Concepts

### Package Structure
Java uses packages (similar to C# namespaces) for organizing code. Package names match directory structure:
- `com.matjazt.networkmonitor.api` → `com/matjazt/networkmonitor/api/`

### Separation of Concerns
Code is organized in layers:
1. **API layer**: HTTP endpoints (NetworkResource)
2. **Service layer**: Business logic (MqttService, MessageProcessingService)
3. **Repository layer**: Data access (NetworkRepository, DeviceStatusRepository)
4. **Entity layer**: Database mapping (Network, DeviceStatusHistory)
5. **Model layer**: Data transfer (NetworkStatusMessage)

Each layer has a specific responsibility. Similar to MVC or clean architecture patterns.

### Dependency Injection
Jakarta EE uses CDI for dependency injection. `@Inject` annotation injects dependencies automatically.

Example:
```java
@Inject
private NetworkRepository repository;
```

Container creates and manages instances. Similar to constructor injection in .NET.

### Annotations
Java uses annotations (like C# attributes) extensively for configuration:
- `@Entity`, `@Table`: JPA mapping
- `@Path`, `@GET`: REST endpoints
- `@Inject`: dependency injection
- `@ApplicationScoped`, `@Singleton`: bean scopes
- `@PostConstruct`, `@PreDestroy`: lifecycle callbacks

Annotations provide metadata that frameworks use at runtime.

## Maven Lifecycle

Understanding Maven build phases:

- `mvn clean`: deletes target/ directory
- `mvn compile`: compiles Java sources to .class files
- `mvn test`: runs unit tests
- `mvn package`: creates WAR file
- `mvn install`: installs WAR to local Maven repository
- `mvn clean package`: full rebuild

Most common: `mvn clean package` to build deployable WAR.

## Adding New Features

### Adding a new REST endpoint:
1. Add method to `NetworkResource.java` or create new resource class
2. Annotate with `@GET/@POST/etc.` and `@Path`
3. Rebuild with `mvn package`

### Adding a database table:
1. Create entity class in `entity/` package
2. Annotate with `@Entity` and field mappings
3. Add to `persistence.xml` class list
4. Create repository in `repository/` package
5. Update `database/schema.sql`

### Adding configuration:
1. Add property to `microprofile-config.properties`
2. Inject in `ConfigProvider.java` with `@ConfigProperty`
3. Add getter method

## Comparison with .NET

| Jakarta EE | .NET Equivalent |
|------------|-----------------|
| Maven | MSBuild + NuGet |
| pom.xml | .csproj |
| WAR file | Published application |
| JPA/Entities | Entity Framework/DbContext |
| CDI | Built-in DI Container |
| JAX-RS | ASP.NET Web API |
| @Path | [Route] |
| @Inject | Constructor injection |
| persistence.xml | DbContext configuration |
| JPQL | LINQ to Entities |
| EntityManager | DbContext |

Main differences:
- Java uses annotations more heavily than attributes
- Configuration often in XML (older standard) or properties files
- Explicit getter/setter methods instead of auto-properties
- Package structure mirrors directory structure (strict convention)
